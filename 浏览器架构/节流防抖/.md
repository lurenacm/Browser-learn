# 节流和防抖
> 适合高频触发的场景，比如按钮的点击，input 搜索框的模糊搜索，页面滚动等。
* 高频触发的时间由我们来指定。触发

## 防抖 debounce
> 防抖特点：在某一次高频的触发下，我们只识别一次。可以控制开始的一次触发，还是最后一次触发。
比如：我们规定了高频触发的时间是 400ms，在这 400ms 内事件被多次触发，不论触发的时间有多长，我们只执行一次。
### 实现防抖函数
* 开胃菜：先看一个可以实现防抖功能的思路，使用一个标识 flag 和 setTimeout() 实现控制设定时间内的触发。
``` js
let flag = false
btn.onclick = function(){
    if(flag) return
    flag = true
    console.log('ok')
    setTimeout(() => {
        flag = false
    }, 2000)
}
```
#### 封装一个 debounce 的防抖函数
> 思路：我们需要一个自定义的高频时间，且需要一个处理函数我们设置成回调函数，还可以指定触发是开始的一次还是结束的一次。要点是这个函数只在规定的时间内执行一次。
``` js
function debounce(callback, wait, immediate){
    // 参数的处理，防止漏传，误传。
    if(typeof callback !=="function") throw new TypeError("func must be an function")
    if(typeof wait == "undefined") wait = 500
    if(typeof wait === "boolean") {
        immediate = wait
        wait = 500
    }
    if(typeof immediate !=="boolean") immediate = false

    // 返回真正执行的函数。和开胃菜一样的思路，需要定时器和标识
    let timer = null
    return function proxy(){
        // 在规定时间内再次点击，那么我们清除上一次的定时器，使用新的定时器。
        // 假设规定时间内被点击了 100 次，那么前面的 99次 都是无效的，最后一次才有效果。
        clearTimeout(timer)
        timer = setTimeout(() => {
            callback()
        }, wait)
    }
}

function handel() {
    console.log("ajax sended -- ok")
}
box.onclick = debounce(handel, 500, true)
```
> 上面的代码保证了高频触发后只执行最后一次。

**上面的代码看似是成功了，但是事件被点击的时候会默认传入一个事件对象`event`或其他得到参数，实际业务中往往需要获取这个 event 中 value 传递给 ajax，那我们要怎么获取event和其他参数呢？**
> 毫无疑问，我们需要在定义函数 proxy 中获取这个 event 值，再传递给真正要执行的回调函数`handel`。
``` js
return function proxy(...params){
    let self  = this
    clearTimeout(timer)
    timer = setTimeout(() => {
        callback.call(self, ...params)
    }, wait)
}
```
> 上面的代码为什么需要改变我们的 this，因为是 `box` 调用了`proxy`这个函数，`proxy` 的 this 就指向`box`，使用`call`改变 this 才可以获取 `box` 节点对象中传递过来的 `event` 参数。

**上面的代码成了，但是如果我们想要第一次点击就立即执行，而不是在高频时间内执行最后一次，该怎么处理**
> 思路：需要利用变量 immediate 作为一个标识来实现。
``` js
return function proxy(...params){
    let self  = this,
     now = immediate && !timer   // timer 是 null 表示是第一次，now 才是第一次
    clearTimeout(timer)
    timer = setTimeout(() => {
        // 判断 immediate 的状态，立即执行的不需要间隔。
        !immediate ? callback.call(self, ...params): null
    }, wait)

    // 根据 immediate 控制第一次点击是否立即执行
    now ? callback.call(self, ...params) : null
}
```
##### 完整代码如下
``` js
function debounce(callback, wait, immediate) {
    if (typeof callback !== "function") throw new TypeError("func must be an function")
    if (typeof wait == "undefined") wait = 500
    if (typeof wait === "boolean") {
        immediate = wait
        wait = 500
    }
    if (typeof immediate !== "boolean") immediate = false

    let timer = null
    return function proxy(...params) {
        let self = this
        let now = immediate && !timer;
        clearTimeout(timer)
        timer = setTimeout(() => {
            timer = null
            !immediate ? callback.call(self, ...params) : null
        }, wait)
        now ? callback.call(self, ...params) : null
    }
}
```
[防抖效果如下](./img/防抖.jpg)


``` js
function debounce(func, wait, immediate) {
    var timeout;
    return function () {
        var context = this;
        var args = arguments;
        if (timeout) clearTimeout(timeout);
        if (immediate) {
            // 如果已经执行过，不再执行
            var callNow = !timeout;
            timeout = setTimeout(function(){
                timeout = null;
            }, wait)
            if (callNow) func.apply(context, args)
        }
        else {
            timeout = setTimeout(function(){
                func.apply(context, args)
            }, wait);
        }
    }
}
```

同学你好，我想过很多种方式认识你，但是都觉得让人很唐突，哈哈。见过你几次以后，感觉你就像一颗种子一样，在我心里面发芽，你是一个上进，努力的女孩儿，也是一个小俏皮的有趣女生。

## 节流 throttle
> 节流特点：在某一次高频的触发下，不止触发一次，在我们设定的高频时间内，只要达到触发的事件都会触发一次。页面的滚动就适合节流的控制
比如：我们规定了高频触发的时间是 400ms，在这 400ms 内事件被多次触发。假设触发的时间有3分钟，那么触发的次数就是 3*60*1000/400 = 450次

### 实现一个 throttle 节流函数
> 思路：和防抖一样相似。
```js


```



## 参考
[节流防抖的使用场景](https://juejin.cn/post/6844903669389885453)
[节流防抖实现](https://github.com/mqyqingfeng/Blog/issues/22)



 