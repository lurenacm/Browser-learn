# 节流和防抖
> 适合高频触发的场景，比如按钮的点击，input 搜索框的模糊搜索，页面滚动等。
* 高频的时间由我们来指定。

## 防抖 debounce
> 防抖特点：在某一次高频的触发下，我们只识别一次。可以控制开始的一次触发，还是最后一次触发。
比如：我们规定了高频触发的时间是 400ms，在这 400ms 内事件被多次触发，不论触发的时间有多长，我们只执行一次。
### 实现防抖函数
* 开胃菜：先看一个可以实现防抖功能的思路，使用一个标识 flag 和 setTimeout() 实现控制设定时间内的触发。
``` js
let flag = false
btn.onclick = function(){
    if(flag) return
    flag = true
    console.log('ok')
    setTimeout(() => {
        flag = false
    }, 2000)
}
```
* 封装一个 debounce 的防抖函数
> 思路：我们需要一个自定义的高频时间，且需要一个处理函数我们设置成回调函数，还可以指定触发是开始的一次还是结束的一次。要点是这个函数只在规定的时间内执行一次。
``` js
function debounce(callback, wait, immediate){
    // 参数的处理，防止漏传，误传。
    if(typeof callback !=="function") throw new TypeError("func must be an function")
    if(typeof wait == "undefined") wait = 500
    if(typeof wait === "boolean") {
        immediate = wait
        wait = 500
    }
    if(typeof immediate !=="boolean") immediate = false

    // 返回真正执行的函数。和开胃菜一样的思路，需要定时器和标识
    let timer = null
    return function proxy(){
        // 在规定时间内再次点击，那么我们清除上一次的定时器，使用新的定时器。
        // 假设规定时间内被点击了 100 次，那么前面的 99次 都是无效的，最后一次才有效果。
        clearTimeout(timer)
        timer = setTimeout(() => {
            callback()
        }, wait)
    }
}

function handel() {
    console.log("ajax sended -- ok")
}
box.onclick = debounce(handel, 500, true)
```
> 上面的代码保证了高频触发后只执行最后一次。

## 节流 throttle
> 节流特点：在某一次高频的触发下，不止触发一次，在我们设定的高频时间内，只要达到触发的事件都会触发一次。
比如：我们规定了高频触发的时间是 400ms，在这 400ms 内事件被多次触发。假设触发的时间有3分钟，那么触发的次数就是 3*60*1000/400 = 450次

``` js


```


## 参考
[节流防抖的使用场景](https://juejin.cn/post/6844903669389885453)
[节流防抖实现](https://github.com/mqyqingfeng/Blog/issues/22)



 